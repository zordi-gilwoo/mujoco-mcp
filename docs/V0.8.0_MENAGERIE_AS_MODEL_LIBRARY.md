# MuJoCo Menagerie as MCP Model Library - v0.8.0 Design

## Vision

MuJoCo Menagerie serves as a comprehensive model library for MuJoCo MCP. Users can load any robot from Menagerie through natural language commands and perform all MCP operations on them.

## Core Concept

```
User: "Load the Franka Panda robot from Menagerie"
MCP: Loads Franka → Displays in viewer → Ready for control

User: "Move the end effector to position [0.5, 0.3, 0.4]"  
MCP: Controls the loaded Franka robot

User: "Load Boston Dynamics Spot instead"
MCP: Switches to Spot model → Ready for quadruped control
```

## Implementation Design

### 1. New MCP Tools

```python
# Core Menagerie Tools
- load_menagerie_model(name: str, version: str = "latest") 
  # Load any model from Menagerie by name
  
- list_menagerie_models(category: str = None)
  # Show available models, optionally filtered by category
  
- search_menagerie_models(query: str)
  # Search models by name, type, or capabilities
  
- get_menagerie_model_info(name: str)
  # Detailed info: joints, actuators, sensors, quality grade
```

### 2. Enhanced Natural Language

```python
# Examples of natural language commands:
"Load the Franka Panda robot"
"Show me all available quadruped robots"
"Load a humanoid robot"
"Switch to the Shadow Hand"
"What robots can do manipulation?"
```

### 3. Model Manager Architecture

```python
class MenagerieModelManager:
    def __init__(self):
        self.menagerie_path = self._setup_menagerie()
        self.model_registry = self._scan_models()
        self.loaded_model = None
        
    def load_model(self, model_name: str) -> Dict[str, Any]:
        """Load a Menagerie model and create simulation"""
        # 1. Find model in registry
        model_info = self.model_registry.get(model_name)
        
        # 2. Load XML and assets
        xml_path = model_info['xml_path']
        
        # 3. Create MuJoCo model
        mjcf_model = mujoco.MjModel.from_xml_path(xml_path)
        
        # 4. Send to viewer
        result = self.viewer_client.load_model(mjcf_model)
        
        # 5. Return model info
        return {
            "model_id": result["model_id"],
            "name": model_name,
            "category": model_info["category"],
            "joints": model_info["num_joints"],
            "actuators": model_info["num_actuators"]
        }
```

### 4. Model Registry Structure

```python
model_registry = {
    "franka_panda": {
        "category": "arms",
        "xml_path": "menagerie/franka_emika_panda/panda.xml",
        "scene_path": "menagerie/franka_emika_panda/scene.xml",
        "quality": "A",
        "num_joints": 7,
        "num_actuators": 7,
        "has_gripper": True,
        "description": "7-DOF collaborative robot arm"
    },
    "spot": {
        "category": "quadrupeds", 
        "xml_path": "menagerie/boston_dynamics_spot/spot.xml",
        "quality": "A+",
        "num_joints": 12,
        "num_actuators": 12,
        "description": "Quadruped robot from Boston Dynamics"
    },
    # ... more models
}
```

### 5. Category-Specific Control Extensions

Once a model is loaded, enable appropriate control tools:

#### For Arms (e.g., Franka, UR5e):
```python
- set_end_effector_pose(x, y, z, roll, pitch, yaw)
- open_gripper() / close_gripper()
- get_jacobian()
- apply_cartesian_force(fx, fy, fz)
```

#### For Quadrupeds (e.g., Spot, Go2):
```python
- set_gait(type: "walk" | "trot" | "gallop")
- move_base(x, y, theta)
- set_body_height(height: float)
- balance_on_three_legs()
```

#### For Humanoids (e.g., H1, Apollo):
```python
- set_posture(name: str)  # "stand", "crouch", etc.
- walk_to(x, y)
- maintain_balance()
- reach_target(hand: "left" | "right", position)
```

## User Experience Flow

### 1. Discovery
```
User: "What robot models are available?"
MCP: "Available categories: arms (8), quadrupeds (5), humanoids (3), 
     end_effectors (4), bipeds (2). Use 'list models in <category>' 
     for details."

User: "List models in arms"
MCP: "Arm models available:
     - franka_panda: 7-DOF collaborative robot (Quality: A)
     - ur5e: Universal Robots UR5e (Quality: A+)
     - kuka_iiwa: KUKA LBR iiwa 14 (Quality: B+)
     ..."
```

### 2. Loading
```
User: "Load the Franka Panda"
MCP: "Loading Franka Emika Panda...
     ✓ Model loaded successfully
     - 7 joints, 7 actuators
     - Gripper available
     - Ready for control"
```

### 3. Control
```
User: "Open the gripper"
MCP: "Gripper opened to 8cm"

User: "Move end effector to [0.5, 0.3, 0.4]"
MCP: "Moving to target position...
     ✓ Reached [0.500, 0.300, 0.400]"
```

### 4. Switching Models
```
User: "Load Spot instead"
MCP: "Switching from Franka Panda to Boston Dynamics Spot...
     ✓ Spot loaded successfully
     - 12 joints, 12 actuators  
     - Quadruped locomotion ready"
```

## Technical Considerations

### 1. Asset Path Resolution
```python
def resolve_asset_paths(xml_content: str, model_dir: str) -> str:
    """Fix relative paths in XML to absolute paths"""
    # Replace mesh="assets/..." with full paths
    # Handle texture paths
    # Update compiler paths
```

### 2. Model Validation
```python
def validate_model(model_path: str) -> bool:
    """Check if model meets requirements"""
    # Check MuJoCo version compatibility
    # Verify all assets exist
    # Test loading without viewer
```

### 3. Performance Optimization
- Cache loaded models in memory
- Precompute model metadata
- Lazy load assets only when needed

## Testing Strategy

### 1. Model Coverage Tests
- Load each model category
- Verify all models in registry
- Check asset loading

### 2. Control Tests
- Test category-specific controls
- Verify joint limits respected
- Check actuator responses

### 3. Integration Tests
- Natural language model loading
- Model switching scenarios
- Error handling for missing models

## Success Metrics

1. **Model Support**: 80%+ of Menagerie models loadable
2. **Load Time**: <3 seconds for average model
3. **Control Accuracy**: All models controllable via MCP tools
4. **User Experience**: Natural language for all operations

## Implementation Timeline

### Week 1: Foundation
- Set up Menagerie repository
- Build model registry scanner
- Create model loading infrastructure

### Week 2: Core Tools
- Implement load_menagerie_model
- Add list and search tools
- Natural language enhancements

### Week 3: Robot-Specific Controls
- Arm control tools
- Quadruped control tools
- Basic humanoid support

### Week 4: Polish & Testing
- Comprehensive model testing
- Performance optimization
- Documentation

### Week 5: Release
- Final testing
- Example notebooks
- Release v0.8.0

## Conclusion

By treating MuJoCo Menagerie as a model library for MCP, we transform the project from a toy physics demo to a comprehensive robotics control platform. Users can naturally load and control any robot from the Menagerie collection, making MCP a powerful tool for robotics research and development.